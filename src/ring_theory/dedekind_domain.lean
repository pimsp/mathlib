import ring_theory.fractional_ideal
import ring_theory.principal_ideal_domain

universes u v

open localization

namespace ring

open fractional_ideal

variables {R : Type u} {K : Type v} [field K]
variables [integral_domain R] (g : fraction_map R K)
open units

/-- `to_principal_ideal x` sends `x ≠ 0 : K` to the fractional ideal generated by `x` -/
def to_principal_ideal : units g.codomain →* units (fractional_ideal g) :=
{ to_fun := λ x,
  ⟨ span_singleton x,
    span_singleton x⁻¹,
    by simp only [span_singleton_one, coe_unit_mul_inv', span_singleton_mul_span_singleton],
    by simp only [span_singleton_one, coe_unit_inv_mul', span_singleton_mul_span_singleton]⟩,
  map_mul' := λ x y, ext (by simp only [coe_mk, units.coe_mul, span_singleton_mul_span_singleton]),
  map_one' := ext (by simp only [span_singleton_one, coe_mk, units.coe_one]) }

instance principal_ideals.normal : (to_principal_ideal g).range.normal :=
subgroup.normal_of_comm _

/-- The Picard group with respect to `g : fraction_map R K` is the group of invertible fractional ideals modulo the principal ideals. -/
@[irreducible]
def picard_group_WRT := quotient_group.quotient (to_principal_ideal g).range

/-- The Picard group is the group of invertible fractional ideals in the fraction field modulo the principal ideals. -/
def picard_group (R : Type*) [integral_domain R] := picard_group_WRT (of R)

variables {K' : Type*} [field K'] (g) (g' : fraction_map R K')

section
local attribute [semireducible] picard_group picard_group_WRT

instance picard_group_WRT.comm_group : comm_group (picard_group_WRT g) :=
quotient_group.comm_group _

noncomputable instance picard_group.comm_group : comm_group (picard_group R) :=
quotient_group.comm_group _

def map_units_equiv (e : units (fractional_ideal g) ≃* units (fractional_ideal g'))
  (he : ∀ I, I ∈ (to_principal_ideal g).range ↔ e I ∈ (to_principal_ideal g').range) :
  picard_group_WRT g ≃* picard_group_WRT g' :=
quotient_group.map_equiv _ e (subgroup.ext he)

end

example (x : K) (h : x ≠ 0) : units K := units.mk0 x h

def map_equiv {K' : Type*} [field K'] {g : fraction_map R K} (g' : fraction_map R K')
  (e : fractional_ideal g ≃* fractional_ideal g')
  (he : ∀ I, (∃ x, span_singleton x = I) ↔ (∃ y, span_singleton y = e I)):
  picard_group_WRT g ≃* picard_group_WRT g' :=
map_units_equiv _ _ (units.map_equiv e) begin
  intro I,
  split; rintros ⟨⟨x, y, hxy, hyx⟩, h⟩,
  { obtain ⟨x', h'⟩ := (he I).mp ⟨x, units.ext_iff.mp h⟩,
    refine ⟨units.mk0 x' _, units.ext_iff.mpr h'⟩,
    rintro rfl,
    have : e I * e (I⁻¹ : units _) = 1,
    { rw [←e.map_mul, ←units.coe_mul, mul_right_inv, units.coe_one, e.map_one] },
    simpa [←h'] using this },
  { obtain ⟨x', h'⟩ := (he I).mpr ⟨x, units.ext_iff.mp h⟩,
    refine ⟨units.mk0 x' _, units.ext_iff.mpr h'⟩,
    rintro rfl,
    have : (I * (I⁻¹ : units _) : fractional_ideal g) = 1,
    { rw [←units.coe_mul, mul_right_inv, units.coe_one] },
    simpa [←h'] using this },
end

noncomputable def canonical_equiv {K' : Type*} [field K'] {g : fraction_map R K}
  (g' : fraction_map R K') : picard_group_WRT g ≃* picard_group_WRT g' :=
have inj_id : function.injective (ring_hom.id R) := λ x y h, h,
map_equiv _ (canonical_equiv g g') (λ I,
  ⟨ λ ⟨x, hx⟩, hx ▸ ⟨g.map g' inj_id x, fractional_ideal.ext_iff.mp
      (λ x', (canonical_equiv_span_singleton g g' x).symm ▸ iff.rfl)⟩,
    λ ⟨y, hy⟩, have hy' : canonical_equiv g' g (span_singleton y) = I :=
        hy.symm ▸ canonical_equiv_flip g' g I,
      hy' ▸ ⟨g'.map g inj_id y, fractional_ideal.ext_iff.mp
        (λ y', (canonical_equiv_span_singleton g' g y).symm ▸ iff.rfl)⟩⟩)

end ring
