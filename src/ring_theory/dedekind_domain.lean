import ring_theory.fractional_ideal
import ring_theory.principal_ideal_domain

universes u v

open localization

namespace ring

open fractional_ideal

variables {R : Type u} {K : Type v} [field K]

variables [integral_domain R] (g : fraction_map R K)

/-- `to_principal_ideal x` sends `x ≠ 0 : K` to the fractional ideal generated by `x` -/
def to_principal_ideal : units K →* units (fractional_ideal g) :=
{ to_fun := λ x, ⟨span_singleton x, span_singleton x⁻¹, by simp only [span_singleton_one, coe_unit_mul_inv', span_singleton_mul_span_singleton], by simp only [span_singleton_one, coe_unit_inv_mul', span_singleton_mul_span_singleton]⟩,
  map_mul' := λ x y, units.ext (by simp only [units.coe_mk, units.coe_mul, span_singleton_mul_span_singleton]),
  map_one' := units.ext (by simp only [span_singleton_one, units.coe_mk, units.coe_one]) }

/-- The Picard group with respect to `g : fraction_map R K` is the group of invertible fractional ideals modulo the principal ideals. -/
def picard_group_WRT := quotient_group.quotient (set.range (to_principal_ideal g))

instance : normal_subgroup (set.range (to_principal_ideal g)) := sorry

-- TODO: fix this when normal subgroups get bundled / quotients use bundled normal subgroups
instance : comm_group (picard_group_WRT g) :=
begin
  convert @quotient_group.comm_group (units (fractional_ideal g)) sorry (set.range (to_principal_ideal g)) sorry,
  sorry
end

#check localization

@[simp] lemma ring_equiv.refl_apply {x : R} : ring_equiv.refl R x = x := rfl

@[simp] lemma ring_equiv.refl_to_monoid_hom : (ring_equiv.refl R).to_monoid_hom = ring_hom.id R := rfl

@[simp] lemma submonoid.map_id {P} : submonoid.map (ring_hom.id R : R →* R) P = P := by { ext, simp }

def picard_group_iso {K' : Type*} [field K'] {g : fraction_map R K}
  (g' : fraction_map R K') : picard_group_WRT g ≃* picard_group_WRT g' :=
{ to_fun := quotient_group.lift _ ((monoid_hom.of quotient_group.mk).comp (fractional_ideal_iso g').to_monoid_hom) _,
  map_mul' := _ }

/-- Condition (DD3) of being a Dedekind domain: all nonzero fractional ideals are invertible. -/
def DD3 [integral_domain R] (g : fraction_map R K) : Prop :=
∀ {I : fractional_ideal g}, I ≠ 0 → I * I⁻¹ = 1

lemma DD3_of_principal_ideal_domain {R} [principal_ideal_domain R] (g : fraction_map R K) : DD3 g :=
λ I hI, fractional_ideal.invertible_of_principal I hI

end ring
